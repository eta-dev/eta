{"version":3,"file":"eta.cjs.js","sources":["../src/err.ts","../src/polyfills.ts","../src/utils.ts","../src/parse.ts","../src/compile-string.ts","../src/storage.ts","../src/containers.ts","../src/config.ts","../src/compile.ts","../src/file-methods.ts","../src/file-utils.ts","../src/file-handlers.ts","../src/file-helpers.ts","../src/render.ts","../src/index.ts"],"sourcesContent":["function setPrototypeOf(obj: any, proto: any) {\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(obj, proto)\n  } else {\n    obj.__proto__ = proto\n  }\n}\n\n// This is pretty much the only way to get nice, extended Errors\n// without using ES6\n\n/**\n * This returns a new Error with a custom prototype. Note that it's _not_ a constructor\n *\n * @param message Error message\n *\n * **Example**\n *\n * ```js\n * throw EtaErr(\"template not found\")\n * ```\n */\n\nexport default function EtaErr(message: string): Error {\n  var err = new Error(message)\n  setPrototypeOf(err, EtaErr.prototype)\n  return err\n}\n\nEtaErr.prototype = Object.create(Error.prototype, {\n  name: { value: 'Eta Error', enumerable: false },\n})\n\n/**\n * Throws an EtaErr with a nicely formatted error and message showing where in the template the error occurred.\n */\n\nexport function ParseErr(message: string, str: string, indx: number) {\n  var whitespace = str.slice(0, indx).split(/\\n/)\n\n  var lineNo = whitespace.length\n  var colNo = whitespace[lineNo - 1].length + 1\n  message +=\n    ' at line ' +\n    lineNo +\n    ' col ' +\n    colNo +\n    ':\\n\\n' +\n    '  ' +\n    str.split(/\\n/)[lineNo - 1] +\n    '\\n' +\n    '  ' +\n    Array(colNo).join(' ') +\n    '^'\n  throw EtaErr(message)\n}\n","import EtaErr from './err'\n\n/**\n * @returns The global Promise function\n */\n\nexport var promiseImpl: PromiseConstructor = new Function('return this')().Promise\n\n/**\n * @returns A new AsyncFunction constuctor\n */\n\nexport function getAsyncFunctionConstructor(): Function {\n  try {\n    return new Function('return (async function(){}).constructor')()\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw EtaErr(\"This environment doesn't support async/await\")\n    } else {\n      throw e\n    }\n  }\n}\n\n/**\n * str.trimLeft polyfill\n *\n * @param str - Input string\n * @returns The string with left whitespace removed\n *\n */\n\nexport function trimLeft(str: string): string {\n  // eslint-disable-next-line no-extra-boolean-cast\n  if (!!String.prototype.trimLeft) {\n    return str.trimLeft()\n  } else {\n    return str.replace(/^\\s+/, '')\n  }\n}\n\n/**\n * str.trimRight polyfill\n *\n * @param str - Input string\n * @returns The string with right whitespace removed\n *\n */\n\nexport function trimRight(str: string): string {\n  // eslint-disable-next-line no-extra-boolean-cast\n  if (!!String.prototype.trimRight) {\n    return str.trimRight()\n  } else {\n    return str.replace(/\\s+$/, '') // TODO: do we really need to replace BOM's?\n  }\n}\n","// TODO: allow '-' to trim up until newline. Use [^\\S\\n\\r] instead of \\s\n// TODO: only include trimLeft polyfill if not in ES6\n\nimport { trimLeft, trimRight } from './polyfills'\n\n/* TYPES */\n\nimport { EtaConfig } from './config'\n\ninterface EscapeMap {\n  '&': '&amp;'\n  '<': '&lt;'\n  '>': '&gt;'\n  '\"': '&quot;'\n  \"'\": '&#39;'\n  [index: string]: string\n}\n\n/* END TYPES */\n\nexport function hasOwnProp(obj: object, prop: string) {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function copyProps<T>(toObj: T, fromObj: T) {\n  for (var key in fromObj) {\n    if (hasOwnProp((fromObj as unknown) as object, key)) {\n      toObj[key] = fromObj[key]\n    }\n  }\n  return toObj\n}\n\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */\n\nfunction trimWS(\n  str: string,\n  config: EtaConfig,\n  wsLeft: string | false,\n  wsRight?: string | false\n): string {\n  var leftTrim\n  var rightTrim\n\n  if (Array.isArray(config.autoTrim)) {\n    // kinda confusing\n    // but _}} will trim the left side of the following string\n    leftTrim = config.autoTrim[1]\n    rightTrim = config.autoTrim[0]\n  } else {\n    leftTrim = rightTrim = config.autoTrim\n  }\n\n  if (wsLeft || wsLeft === false) {\n    leftTrim = wsLeft\n  }\n\n  if (wsRight || wsRight === false) {\n    rightTrim = wsRight\n  }\n\n  if (!rightTrim && !leftTrim) {\n    return str\n  }\n\n  if (leftTrim === 'slurp' && rightTrim === 'slurp') {\n    return str.trim()\n  }\n\n  if (leftTrim === '_' || leftTrim === 'slurp') {\n    // console.log('trimming left' + leftTrim)\n    // full slurp\n\n    str = trimLeft(str)\n  } else if (leftTrim === '-' || leftTrim === 'nl') {\n    // nl trim\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, '')\n  }\n\n  if (rightTrim === '_' || rightTrim === 'slurp') {\n    // full slurp\n    str = trimRight(str)\n  } else if (rightTrim === '-' || rightTrim === 'nl') {\n    // nl trim\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, '') // TODO: make sure this gets \\r\\n\n  }\n\n  return str\n}\n\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */\n\nvar escMap: EscapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n}\n\nfunction replaceChar(s: string): string {\n  return escMap[s]\n}\n\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */\n\nfunction XMLEscape(str: any) {\n  // eslint-disable-line @typescript-eslint/no-explicit-any\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n  var newStr = String(str)\n  if (/[&<>\"']/.test(newStr)) {\n    return newStr.replace(/[&<>\"']/g, replaceChar)\n  } else {\n    return newStr\n  }\n}\n\nexport { trimWS, XMLEscape }\n","import { ParseErr } from './err'\nimport { trimWS } from './utils'\n\n/* TYPES */\n\nimport { EtaConfig } from './config'\n\nexport type TagType = 'r' | 'e' | 'i' | ''\n\nexport interface TemplateObject {\n  t: TagType\n  val: string\n}\n\nexport type AstObject = string | TemplateObject\n\n/* END TYPES */\n\nvar templateLitReg = /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g\n\nvar singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g\n\nvar doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g\n\n/** Escape special regular expression characters inside a string */\n\nfunction escapeRegExp(string: string) {\n  // From MDN\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\n\nexport default function parse(str: string, config: EtaConfig): Array<AstObject> {\n  var buffer: Array<AstObject> = []\n  var trimLeftOfNextStr: string | false = false\n  var lastIndex = 0\n  var parseOptions = config.parse\n\n  /* Adding for EJS compatibility */\n  if (config.rmWhitespace) {\n    // Code taken directly from EJS\n    // Have to use two separate replaces here as `^` and `$` operators don't\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\n    // Essentially, this replaces the whitespace at the beginning and end of\n    // each line and removes multiple newlines.\n    str = str.replace(/[\\r\\n]+/g, '\\n').replace(/^\\s+|\\s+$/gm, '')\n  }\n  /* End rmWhitespace option */\n\n  templateLitReg.lastIndex = 0\n  singleQuoteReg.lastIndex = 0\n  doubleQuoteReg.lastIndex = 0\n\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\n    if (strng) {\n      // if string is truthy it must be of type 'string'\n\n      strng = trimWS(\n        strng,\n        config,\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n        shouldTrimRightOfString\n      )\n\n      if (strng) {\n        // replace \\ with \\\\, ' with \\'\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\n\n        strng = strng.replace(/\\\\|'/g, '\\\\$&').replace(/\\r\\n|\\n|\\r/g, '\\\\n')\n\n        buffer.push(strng)\n      }\n    }\n  }\n\n  var prefixes = [parseOptions.exec, parseOptions.interpolate, parseOptions.raw].reduce(function (\n    accumulator,\n    prefix\n  ) {\n    if (accumulator && prefix) {\n      return accumulator + '|' + escapeRegExp(prefix)\n    } else if (prefix) {\n      // accumulator is falsy\n      return escapeRegExp(prefix)\n    } else {\n      // prefix and accumulator are both falsy\n      return accumulator\n    }\n  },\n  '')\n\n  var parseOpenReg = new RegExp(\n    '([^]*?)' + escapeRegExp(config.tags[0]) + '(-|_)?\\\\s*(' + prefixes + ')?\\\\s*',\n    'g'\n  )\n\n  var parseCloseReg = new RegExp(\n    '\\'|\"|`|\\\\/\\\\*|(\\\\s*(-|_)?' + escapeRegExp(config.tags[1]) + ')',\n    'g'\n  )\n  // TODO: benchmark having the \\s* on either side vs using str.trim()\n\n  var m\n\n  while ((m = parseOpenReg.exec(str))) {\n    lastIndex = m[0].length + m.index\n\n    var precedingString = m[1]\n    var wsLeft = m[2]\n    var prefix = m[3] || '' // by default either ~, =, or empty\n\n    pushString(precedingString, wsLeft)\n\n    parseCloseReg.lastIndex = lastIndex\n    var closeTag\n    var currentObj: AstObject | false = false\n\n    while ((closeTag = parseCloseReg.exec(str))) {\n      if (closeTag[1]) {\n        var content = str.slice(lastIndex, closeTag.index)\n\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex\n\n        trimLeftOfNextStr = closeTag[2]\n\n        var currentType: TagType = ''\n        if (prefix === parseOptions.exec) {\n          currentType = 'e'\n        } else if (prefix === parseOptions.raw) {\n          currentType = 'r'\n        } else if (prefix === parseOptions.interpolate) {\n          currentType = 'i'\n        }\n\n        currentObj = { t: currentType, val: content }\n        break\n      } else {\n        var char = closeTag[0]\n        if (char === '/*') {\n          var commentCloseInd = str.indexOf('*/', parseCloseReg.lastIndex)\n\n          if (commentCloseInd === -1) {\n            ParseErr('unclosed comment', str, closeTag.index)\n          }\n          parseCloseReg.lastIndex = commentCloseInd\n        } else if (char === \"'\") {\n          singleQuoteReg.lastIndex = closeTag.index\n\n          var singleQuoteMatch = singleQuoteReg.exec(str)\n          if (singleQuoteMatch) {\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex\n          } else {\n            ParseErr('unclosed string', str, closeTag.index)\n          }\n        } else if (char === '\"') {\n          doubleQuoteReg.lastIndex = closeTag.index\n          var doubleQuoteMatch = doubleQuoteReg.exec(str)\n\n          if (doubleQuoteMatch) {\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex\n          } else {\n            ParseErr('unclosed string', str, closeTag.index)\n          }\n        } else if (char === '`') {\n          templateLitReg.lastIndex = closeTag.index\n          var templateLitMatch = templateLitReg.exec(str)\n          if (templateLitMatch) {\n            parseCloseReg.lastIndex = templateLitReg.lastIndex\n          } else {\n            ParseErr('unclosed string', str, closeTag.index)\n          }\n        }\n      }\n    }\n    if (currentObj) {\n      buffer.push(currentObj)\n    } else {\n      ParseErr('unclosed tag', str, m.index + precedingString.length)\n    }\n  }\n\n  pushString(str.slice(lastIndex, str.length), false)\n\n  if (config.plugins) {\n    for (var i = 0; i < config.plugins.length; i++) {\n      var plugin = config.plugins[i]\n      if (plugin.processAST) {\n        buffer = plugin.processAST(buffer, config)\n      }\n    }\n  }\n\n  return buffer\n}\n","import Parse from './parse'\n\n/* TYPES */\n\nimport { EtaConfig } from './config'\nimport { AstObject } from './parse'\n\n/* END TYPES */\n\n/**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n *\n * **Example**\n *\n * ```js\n * compileToString(\"Hi <%= it.user %>\", eta.config)\n * // \"var tR='';tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\"\n * ```\n */\n\nexport default function compileToString(str: string, config: EtaConfig) {\n  var buffer: Array<AstObject> = Parse(str, config)\n\n  var res =\n    \"var tR=''\\n\" +\n    (config.useWith ? 'with(' + config.varName + '||{}){' : '') +\n    compileScope(buffer, config) +\n    'if(cb){cb(null,tR)} return tR' +\n    (config.useWith ? '}' : '')\n\n  if (config.plugins) {\n    for (var i = 0; i < config.plugins.length; i++) {\n      var plugin = config.plugins[i]\n      if (plugin.processFnString) {\n        res = plugin.processFnString(res, config)\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * // AST version of 'Hi <%= it.user %>'\n * let templateAST = ['Hi ', { val: 'it.user', t: 'i' }]\n * compileScope(templateAST, eta.config)\n * // \"tR+='Hi ';tR+=E.e(it.user);\"\n * ```\n */\n\nfunction compileScope(buff: Array<AstObject>, config: EtaConfig) {\n  var i = 0\n  var buffLength = buff.length\n  var returnStr = ''\n\n  for (i; i < buffLength; i++) {\n    var currentBlock = buff[i]\n    if (typeof currentBlock === 'string') {\n      var str = currentBlock\n\n      // we know string exists\n      returnStr += \"tR+='\" + str + \"'\\n\"\n    } else {\n      var type = currentBlock.t // ~, s, !, ?, r\n      var content = currentBlock.val || ''\n\n      if (type === 'r') {\n        // raw\n        returnStr += 'tR+=' + content + '\\n'\n      } else if (type === 'i') {\n        // interpolate\n        if (config.autoEscape) {\n          content = 'E.e(' + content + ')'\n        }\n        returnStr += 'tR+=' + content + '\\n'\n        // reference\n      } else if (type === 'e') {\n        // execute\n        returnStr += content + '\\n' // you need a \\n in case you have <% } %>\n      }\n    }\n  }\n\n  return returnStr\n}\n","import { copyProps } from './utils'\n\n/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */\nclass Cacher<T> {\n  constructor(private cache: Record<string, T>) {}\n  define(key: string, val: T) {\n    this.cache[key] = val\n  }\n  get(key: string) {\n    // string | array.\n    // TODO: allow array of keys to look down\n    // TODO: create plugin to allow referencing helpers, filters with dot notation\n    return this.cache[key]\n  }\n  remove(key: string) {\n    delete this.cache[key]\n  }\n  reset() {\n    this.cache = {}\n  }\n  load(cacheObj: Record<string, T>) {\n    copyProps(this.cache, cacheObj)\n  }\n}\n\nexport { Cacher }\n","import { Cacher } from './storage'\n\n/* TYPES */\n\nimport { TemplateFunction } from './compile'\n\n/* END TYPES */\n\n/**\n * Eta's template storage\n *\n * Stores partials and cached templates\n */\n\nvar templates = new Cacher<TemplateFunction>({})\n\nexport { templates }\n","import { templates } from './containers'\nimport { copyProps, XMLEscape } from './utils'\nimport EtaErr from './err'\n\n/* TYPES */\n\nimport { TemplateFunction } from './compile'\nimport { Cacher } from './storage'\n\ntype trimConfig = 'nl' | 'slurp' | false\n\nexport interface EtaConfig {\n  /** Name of the data object. Default `it` */\n  varName: string\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\n  autoTrim: trimConfig | [trimConfig, trimConfig]\n  /** Remove all safe-to-remove whitespace */\n  rmWhitespace: boolean\n  /** Whether or not to automatically XML-escape interpolations. Default true */\n  autoEscape: boolean\n  /** Delimiters: by default `['<%', '%>']` */\n  tags: [string, string]\n  /** Parsing options */\n  parse: {\n    /** Which prefix to use for interpolation. Default `\"=\"` */\n    interpolate: string\n    /** Which prefix to use for raw interpolation. Default `\"~\"` */\n    raw: string\n    /** Which prefix to use for evaluation. Default `\"\"` */\n    exec: string\n  }\n  /** XML-escaping function */\n  e: (str: string) => string\n  plugins: Array<{ processFnString?: Function; processAST?: Function }>\n  /** Compile to async function */\n  async: boolean\n  /** Holds template cache */\n  templates: Cacher<TemplateFunction>\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  cache: boolean\n  /** Directories that contain templates */\n  views?: string | Array<string>\n  /** Where should absolute paths begin? Default '/' */\n  root?: string\n  /** Absolute path to template file */\n  filename?: string\n  /** Name of template file */\n  name?: string\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  'view cache'?: boolean\n  /** Make data available on the global object instead of varName */\n  useWith?: boolean\n  [index: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\nexport interface EtaConfigWithFilename extends EtaConfig {\n  filename: string\n}\n\nexport type PartialConfig = Partial<EtaConfig>\n\n/* END TYPES */\n\n/**\n * Include a template based on its name (or filepath, if it's already been cached).\n *\n * Called like `E.include(templateNameOrPath, data)`\n */\n\nfunction includeHelper(this: EtaConfig, templateNameOrPath: string, data: object): string {\n  var template = this.templates.get(templateNameOrPath)\n  if (!template) {\n    throw EtaErr('Could not fetch template \"' + templateNameOrPath + '\"')\n  }\n  return template(data, this)\n}\n\n/** Eta's base (global) configuration */\nvar config: EtaConfig = {\n  varName: 'it',\n  autoTrim: [false, 'nl'],\n  rmWhitespace: false,\n  autoEscape: true,\n  tags: ['<%', '%>'],\n  parse: {\n    interpolate: '=',\n    raw: '~',\n    exec: '',\n  },\n  async: false,\n  templates: templates,\n  cache: false,\n  plugins: [],\n  useWith: false,\n  e: XMLEscape,\n  include: includeHelper,\n}\n\n/**\n * Takes one or two partial (not necessarily complete) configuration objects, merges them 1 layer deep into eta.config, and returns the result\n *\n * @param override Partial configuration object\n * @param baseConfig Partial configuration object to merge before `override`\n *\n * **Example**\n *\n * ```js\n * let customConfig = getConfig({tags: ['!#', '#!']})\n * ```\n */\n\nfunction getConfig(override: PartialConfig, baseConfig?: EtaConfig): EtaConfig {\n  // TODO: run more tests on this\n\n  var res: PartialConfig = {} // Linked\n  copyProps(res, config) // Creates deep clone of eta.config, 1 layer deep\n\n  if (baseConfig) {\n    copyProps(res, baseConfig)\n  }\n\n  if (override) {\n    copyProps(res, override)\n  }\n\n  return res as EtaConfig\n}\n\n/** Update Eta's base config */\n\nfunction configure(options: PartialConfig) {\n  return copyProps(config, options)\n}\n\nexport { config, getConfig, configure }\n","import compileToString from './compile-string'\nimport { getConfig } from './config'\nimport EtaErr from './err'\n\n/* TYPES */\n\nimport { EtaConfig, PartialConfig } from './config'\nimport { CallbackFn } from './file-handlers'\nimport { getAsyncFunctionConstructor } from './polyfills'\nexport type TemplateFunction = (data: object, config: EtaConfig, cb?: CallbackFn) => string\n\n/* END TYPES */\n\n/**\n * Takes a template string and returns a template function that can be called with (data, config, [cb])\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n *\n * **Example**\n *\n * ```js\n * let compiledFn = eta.compile(\"Hi <%= it.user %>\")\n * // function anonymous()\n * let compiledFnStr = compiledFn.toString()\n * // \"function anonymous(it,E,cb\\n) {\\nvar tR='';tR+='Hi ';tR+=E.e(it.user);if(cb){cb(null,tR)} return tR\\n}\"\n * ```\n */\n\nexport default function compile(str: string, config?: PartialConfig): TemplateFunction {\n  var options: EtaConfig = getConfig(config || {})\n  var ctor // constructor\n\n  /* ASYNC HANDLING */\n  // The below code is modified from mde/ejs. All credit should go to them.\n  if (options.async) {\n    ctor = getAsyncFunctionConstructor() as FunctionConstructor\n  } else {\n    ctor = Function\n  }\n  /* END ASYNC HANDLING */\n  try {\n    return new ctor(\n      options.varName,\n      'E', // EtaConfig\n      'cb', // optional callback\n      compileToString(str, options)\n    ) as TemplateFunction // eslint-disable-line no-new-func\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw EtaErr(\n        'Bad template syntax\\n\\n' +\n          e.message +\n          '\\n' +\n          Array(e.message.length + 1).join('=') +\n          '\\n' +\n          compileToString(str, options) +\n          '\\n' // This will put an extra newline before the callstack for extra readability\n      )\n    } else {\n      throw e\n    }\n  }\n}\n","export var fs = require('fs')\nexport var path = require('path')\n\nexport var readFileSync = fs.readFileSync\n","import { fs, path, readFileSync } from './file-methods'\nvar _BOM = /^\\uFEFF/\n\n// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from './err'\n\n/* TYPES */\n\nimport { EtaConfig } from './config'\n\n/* END TYPES */\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * If `name` does not have an extension, it will default to `.eta`\n *\n * @param name specified path\n * @param parentfile parent file path\n * @param isDirectory whether parentfile is a directory\n * @return absolute path to template\n */\n\nfunction getWholeFilePath(name: string, parentfile: string, isDirectory?: boolean): string {\n  var includePath = path.resolve(\n    isDirectory ? parentfile : path.dirname(parentfile), // returns directory the parent file is in\n    name // file\n  )\n  var ext = path.extname(name)\n  if (!ext) {\n    includePath += '.eta'\n  }\n  return includePath\n}\n\n/**\n * Get the absolute path to an included template\n *\n * If this is called with an absolute path (for example, starting with '/' or 'C:\\')\n * then Eta will attempt to resolve the absolute path within options.views. If it cannot,\n * Eta will fallback to options.root or '/'\n *\n * If this is called with a relative path, Eta will:\n * - Look relative to the current template (if the current template has the `filename` property)\n * - Look inside each directory in options.views\n *\n * Note: if Eta is unable to find a template using path and options, it will throw an error.\n *\n * @param path    specified path\n * @param options compilation options\n * @return absolute path to template\n */\n\nfunction getPath(path: string, options: EtaConfig) {\n  var includePath: string | false = false\n  var views = options.views\n  var searchedPaths: Array<string> = []\n\n  /** Add a filepath to the list of paths we've checked for a template */\n  function addPathToSearched(pathSearched: string) {\n    if (!searchedPaths.includes(pathSearched)) {\n      searchedPaths.push(pathSearched)\n    }\n  }\n\n  /**\n   * Take a filepath (like 'partials/mypartial.eta'). Attempt to find the template file inside `views`;\n   * return the resulting template file path, or `false` to indicate that the template was not found.\n   *\n   * @param views the filepath that holds templates, or an array of filepaths that hold templates\n   * @param path the path to the template\n   */\n\n  function searchViews(views: Array<string> | string | undefined, path: string): string | false {\n    var filePath\n\n    // If views is an array, then loop through each directory\n    // And attempt to find the template\n    if (\n      Array.isArray(views) &&\n      views.some(function (v) {\n        filePath = getWholeFilePath(path, v, true)\n\n        addPathToSearched(filePath)\n\n        return fs.existsSync(filePath)\n      })\n    ) {\n      // If the above returned true, we know that the filePath was just set to a path\n      // That exists (Array.some() returns as soon as it finds a valid element)\n      return (filePath as unknown) as string\n    } else if (typeof views === 'string') {\n      // Search for the file if views is a single directory\n      filePath = getWholeFilePath(path, views, true)\n\n      addPathToSearched(filePath)\n\n      if (fs.existsSync(filePath)) {\n        return filePath\n      }\n    }\n\n    // Unable to find a file\n    return false\n  }\n\n  // Path starts with '/', 'C:\\', etc.\n  var match = /^[A-Za-z]+:\\\\|^\\//.exec(path)\n\n  // Absolute path, like /partials/partial.eta\n  if (match && match.length) {\n    // We have to trim the beginning '/' off the path, or else\n    // path.resolve(dir, path) will always resolve to just path\n    var formattedPath = path.replace(/^\\/*/, '')\n\n    // First, try to resolve the path within options.views\n    includePath = searchViews(views, formattedPath)\n    if (!includePath) {\n      // If that fails, searchViews will return false. Try to find the path\n      // inside options.root (by default '/', the base of the filesystem)\n      var pathFromRoot = getWholeFilePath(formattedPath, options.root || '/', true)\n\n      addPathToSearched(pathFromRoot)\n\n      includePath = pathFromRoot\n    }\n  } else {\n    // Relative paths\n    // Look relative to a passed filename first\n    if (options.filename) {\n      var filePath = getWholeFilePath(path, options.filename)\n\n      addPathToSearched(filePath)\n\n      if (fs.existsSync(filePath)) {\n        includePath = filePath\n      }\n    }\n    // Then look for the template in options.views\n    if (!includePath) {\n      includePath = searchViews(views, path)\n    }\n    if (!includePath) {\n      throw EtaErr('Could not find the template \"' + path + '\". Paths tried: ' + searchedPaths)\n    }\n  }\n  return includePath\n}\n\n/**\n * Reads a file synchronously\n */\n\nfunction readFile(filePath: string) {\n  try {\n    return readFileSync(filePath).toString().replace(_BOM, '') // TODO: is replacing BOM's necessary?\n  } catch {\n    throw EtaErr(\"Failed to read template at '\" + filePath + \"'\")\n  }\n}\n\nexport { getPath, readFile }\n","// express is set like: app.engine('html', require('eta').renderFile)\n\nimport EtaErr from './err'\nimport compile from './compile'\nimport { getConfig } from './config'\nimport { getPath, readFile } from './file-utils'\nimport { copyProps } from './utils'\nimport { promiseImpl } from './polyfills'\n\n/* TYPES */\n\nimport { EtaConfig, PartialConfig, EtaConfigWithFilename } from './config'\nimport { TemplateFunction } from './compile'\n\nexport type CallbackFn = (err: Error | null, str?: string) => void\n\ninterface DataObj {\n  /** Express.js settings may be stored here */\n  settings?: {\n    [key: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  }\n  [key: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\ninterface PartialConfigWithFilename extends Partial<EtaConfig> {\n  filename: string\n}\n\n/* END TYPES */\n\n/**\n * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function\n *\n * @param filePath Absolute path to template file\n * @param options Eta configuration overrides\n * @param noCache Optionally, make Eta not cache the template\n */\n\nexport function loadFile(\n  filePath: string,\n  options: PartialConfigWithFilename,\n  noCache?: boolean\n): TemplateFunction {\n  var config = getConfig(options)\n  var template = readFile(filePath)\n  try {\n    var compiledTemplate = compile(template, config)\n    if (!noCache) {\n      config.templates.define((config as EtaConfigWithFilename).filename, compiledTemplate)\n    }\n    return compiledTemplate\n  } catch (e) {\n    throw EtaErr('Loading file: ' + filePath + ' failed:\\n\\n' + e.message)\n  }\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @param options   compilation options\n * @return Eta template function\n */\n\nfunction handleCache(options: EtaConfigWithFilename): TemplateFunction {\n  var filename = options.filename\n\n  if (options.cache) {\n    var func = options.templates.get(filename)\n    if (func) {\n      return func\n    }\n\n    return loadFile(filename, options)\n  }\n\n  // Caching is disabled, so pass noCache = true\n  return loadFile(filename, options, true)\n}\n\n/**\n * Try calling handleCache with the given options and data and call the\n * callback with the result. If an error occurs, call the callback with\n * the error. Used by renderFile().\n *\n * @param data template data\n * @param options compilation options\n * @param cb callback\n */\n\nfunction tryHandleCache(data: object, options: EtaConfigWithFilename, cb: CallbackFn | undefined) {\n  if (cb) {\n    try {\n      // Note: if there is an error while rendering the template,\n      // It will bubble up and be caught here\n      var templateFn = handleCache(options)\n      templateFn(data, options, cb)\n    } catch (err) {\n      return cb(err)\n    }\n  } else {\n    // No callback, try returning a promise\n    if (typeof promiseImpl === 'function') {\n      return new promiseImpl<string>(function (resolve: Function, reject: Function) {\n        try {\n          var templateFn = handleCache(options)\n          var result = templateFn(data, options)\n          resolve(result)\n        } catch (err) {\n          reject(err)\n        }\n      })\n    } else {\n      throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\")\n    }\n  }\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * This returns a template function and the config object with which that template function should be called.\n *\n * @remarks\n *\n * It's important that this returns a config object with `filename` set.\n * Otherwise, the included file would not be able to use relative paths\n *\n * @param path path for the specified file (if relative, specify `views` on `options`)\n * @param options compilation options\n * @return [Eta template function, new config object]\n */\n\nfunction includeFile(path: string, options: EtaConfig): [TemplateFunction, EtaConfig] {\n  // the below creates a new options object, using the parent filepath of the old options object and the path\n  var newFileOptions = getConfig({ filename: getPath(path, options) }, options)\n  // TODO: make sure properties are currectly copied over\n  return [handleCache(newFileOptions as EtaConfigWithFilename), newFileOptions]\n}\n\n/**\n * Render a template from a filepath.\n *\n * @param filepath Path to template file. If relative, specify `views` on the config object\n *\n * This can take two different function signatures:\n *\n * - `renderFile(filename, dataAndConfig, [cb])`\n *   - Eta will merge `dataAndConfig` into `eta.config`\n * - `renderFile(filename, data, [config], [cb])`\n *\n * Note that renderFile does not immediately return the rendered result. If you pass in a callback function, it will be called with `(err, res)`. Otherwise, `renderFile` will return a `Promise` that resolves to the render result.\n *\n * **Examples**\n *\n * ```js\n * eta.renderFile(\"./template.eta\", data, {cache: true}, function (err, rendered) {\n *   if (err) console.log(err)\n *   console.log(rendered)\n * })\n *\n * let rendered = await eta.renderFile(\"./template.eta\", data, {cache: true})\n *\n * let rendered = await eta.renderFile(\"./template\", {...data, cache: true})\n * ```\n */\n\nfunction renderFile(filename: string, data: DataObj, config?: PartialConfig, cb?: CallbackFn): any\n\nfunction renderFile(filename: string, data: DataObj, cb?: CallbackFn): any\n\nfunction renderFile(filename: string, data: DataObj, config?: PartialConfig, cb?: CallbackFn) {\n  /*\n  Here we have some function overloading.\n  Essentially, the first 2 arguments to renderFile should always be the filename and data\n  However, with Express, configuration options will be passed along with the data.\n  Thus, Express will call renderFile with (filename, dataAndOptions, cb)\n  And we want to also make (filename, data, options, cb) available\n  */\n\n  var renderConfig: EtaConfigWithFilename\n  var callback: CallbackFn | undefined\n  data = data || {} // If data is undefined, we don't want accessing data.settings to error\n\n  // First, assign our callback function to `callback`\n  // We can leave it undefined if neither parameter is a function;\n  // Callbacks are optional\n  if (typeof cb === 'function') {\n    // The 4th argument is the callback\n    callback = cb\n  } else if (typeof config === 'function') {\n    // The 3rd arg is the callback\n    callback = config\n  }\n\n  // If there is a config object passed in explicitly, use it\n  if (typeof config === 'object') {\n    renderConfig = getConfig((config as PartialConfig) || {}) as EtaConfigWithFilename\n  } else {\n    // Otherwise, get the config from the data object\n    // And then grab some config options from data.settings\n    // Which is where Express sometimes stores them\n    renderConfig = getConfig(data as PartialConfig) as EtaConfigWithFilename\n    if (data.settings) {\n      // Pull a few things from known locations\n      if (data.settings.views) {\n        renderConfig.views = data.settings.views\n      }\n      if (data.settings['view cache']) {\n        renderConfig.cache = true\n      }\n      // Undocumented after Express 2, but still usable, esp. for\n      // items that are unsafe to be passed along with data, like `root`\n      var viewOpts = data.settings['view options']\n\n      if (viewOpts) {\n        copyProps(renderConfig, viewOpts)\n      }\n    }\n  }\n\n  // Set the filename option on the template\n  // This will first try to resolve the file path (see getPath for details)\n  renderConfig.filename = getPath(filename, renderConfig)\n\n  return tryHandleCache(data, renderConfig, callback)\n}\n\nexport { includeFile, renderFile }\n","import { includeFile } from './file-handlers'\n\n/* TYPES */\n\nimport { EtaConfig } from './config'\n\ninterface GenericData {\n  [index: string]: any // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/* END TYPES */\n\n/**\n * Called with `E.includeFile(path, data)`\n */\n\nexport function includeFileHelper(this: EtaConfig, path: string, data: GenericData): string {\n  var templateAndConfig = includeFile(path, this)\n  return templateAndConfig[0](data, templateAndConfig[1])\n}\n","import compile from './compile'\nimport { getConfig } from './config'\nimport { promiseImpl } from './polyfills'\nimport EtaErr from './err'\n\n/* TYPES */\n\nimport { EtaConfig, PartialConfig } from './config'\nimport { TemplateFunction } from './compile'\nimport { CallbackFn } from './file-handlers'\n\n/* END TYPES */\n\nfunction handleCache(template: string | TemplateFunction, options: EtaConfig): TemplateFunction {\n  var templateFunc\n\n  if (options.cache && options.name && options.templates.get(options.name)) {\n    return options.templates.get(options.name)\n  }\n\n  if (typeof template === 'function') {\n    templateFunc = template\n  } else {\n    templateFunc = compile(template, options)\n  }\n\n  // Note that we don't have to check if it already exists in the cache;\n  // it would have returned earlier if it had\n  if (options.cache && options.name) {\n    options.templates.define(options.name, templateFunc)\n  }\n\n  return templateFunc\n}\n\n/**\n * Render a template\n *\n * If `template` is a string, Eta will compile it to a function and then call it with the provided data.\n * If `template` is a template function, Eta will call it with the provided data.\n *\n * If `config.async` is `false`, Eta will return the rendered template.\n *\n * If `config.async` is `true` and there's a callback function, Eta will call the callback with `(err, renderedTemplate)`.\n * If `config.async` is `true` and there's not a callback function, Eta will return a Promise that resolves to the rendered template\n *\n * If `config.cache` is `true` and `config` has a `name` or `filename` property, Eta will cache the template on the first render and use the cached template for all subsequent renders.\n *\n * @param template Template string or template function\n * @param data Data to render the template with\n * @param config Optional config options\n * @param cb Callback function\n */\n\nexport default function render(\n  template: string | TemplateFunction,\n  data: object,\n  config?: PartialConfig,\n  cb?: CallbackFn\n): string | Promise<string> | void {\n  var options = getConfig(config || {})\n\n  if (options.async) {\n    var result\n    if (cb) {\n      // If user passes callback\n      try {\n        // Note: if there is an error while rendering the template,\n        // It will bubble up and be caught here\n        var templateFn = handleCache(template, options)\n        templateFn(data, options, cb)\n      } catch (err) {\n        return cb(err)\n      }\n    } else {\n      // No callback, try returning a promise\n      if (typeof promiseImpl === 'function') {\n        return new promiseImpl(function (resolve: Function, reject: Function) {\n          try {\n            result = handleCache(template, options)(data, options)\n            resolve(result)\n          } catch (err) {\n            reject(err)\n          }\n        })\n      } else {\n        throw EtaErr(\"Please provide a callback function, this env doesn't support Promises\")\n      }\n    }\n  } else {\n    return handleCache(template, options)(data, options)\n  }\n}\n","// @denoify-ignore\n\n/* Export file stuff */\nimport { includeFileHelper } from './file-helpers'\nimport { config } from './config'\n\nconfig.includeFile = includeFileHelper\n\nexport { loadFile, renderFile, renderFile as __express } from './file-handlers'\n\n/* End file stuff */\n\nexport { default as compileToString } from './compile-string'\nexport { default as compile } from './compile'\nexport { default as parse } from './parse'\nexport { default as render } from './render'\nexport { templates } from './containers'\nexport { config, config as defaultConfig, getConfig, configure } from './config'\n"],"names":["Parse","handleCache"],"mappings":"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"}